🏗️ 线性结构

1. 数组 (Array)

```c
// 🎯 核心特征：连续内存、随机访问
int arr[5] = {1, 2, 3, 4, 5};
// 内存布局： [1][2][3][4][5]
//            ↑ 随机访问 arr[2] → 3

// 🔍 识别特征：
// - 固定大小声明
// - 下标直接访问
// - 内存连续分配
```

可视化记忆一下代码：

```
代码: int arr[N] 
     ↓
结构: [元素1][元素2]...[元素N]
     ↓  
特性: 连续内存、O(1)访问、固定大小
```

2. 链表 (Linked List)

```c
// 🎯 核心特征：节点链接、动态大小
struct ListNode {
    int val;
    struct ListNode* next;  // ← 关键指针！
};

// 结构可视化：
// [1] → [2] → [3] → [4] → NULL
//  ↑     ↑     ↑     ↑
// head  next  next  next

// 🔍 识别特征：
// - 节点包含数据+指针
// - 使用 malloc/free 动态管理
// - 遍历需要指针移动
```

可视化记忆：

```
代码: struct Node { data; Node* next; }
     ↓
结构: [data|next] → [data|next] → ... → NULL
     ↓
特性: 动态大小、O(n)访问、插入删除快
```

3. 栈 (Stack)

```c
// 🎯 核心特征：LIFO、只能栈顶操作
#define MAX_SIZE 100
typedef struct {
    int data[MAX_SIZE];
    int top;  // ← 关键指针！
} Stack;

// 操作可视化：
// 栈顶 → [30]
//        [20] 
//        [10] ← 栈底
// push(40): top++ → [40] 新栈顶

// 🔍 识别特征：
// - top 指针跟踪栈顶
// - push/pop 只在栈顶操作
// - 空栈条件: top == -1
```

可视化记忆：

```
代码: top++; data[top] = x;  // push
     ↓
结构: 栈顶 → [最新元素] ↓ [旧元素] ... 
     ↓
特性: 后进先出、只能一端操作
```

4. 队列 (Queue)

```c
// 🎯 核心特征：FIFO、队尾入队、队首出队
typedef struct {
    int data[MAX_SIZE];
    int front, rear;  // ← 关键双指针！
} Queue;

// 操作可视化：
// 队首 → [10][20][30] ← 队尾
//         ↑           ↑
//       front        rear
// 入队: rear++ → [10][20][30][40]
// 出队: front++ → [X][20][30][40]

// 🔍 识别特征：
// - front 和 rear 两个指针
// - 循环数组处理
// - 空队条件: front == rear
```

可视化记忆：

```
代码: front/rear 指针 + 循环数组
     ↓
结构: [出队] ← [元素1][元素2]...[元素N] ← [入队]
     ↓  
特性: 先进先出、两端操作
```

---

🌳 树形结构

5. 二叉树 (Binary Tree)

```c
// 🎯 核心特征：每个节点最多两个子树
struct TreeNode {
    int val;
    struct TreeNode* left;   // ← 左子树指针
    struct TreeNode* right;  // ← 右子树指针
};

// 结构可视化：
//        [1]
//       /   \
//    [2]     [3]
//    / \     / \
//  [4] [5] [6] [7]

// 🔍 识别特征：
// - 节点包含 left/right 指针
// - 递归结构定义
// - 三种遍历方式
```

可视化记忆：

```
代码: struct TreeNode { val; left; right; }
     ↓
结构:     [根节点]
        /      \
    [左子树]  [右子树]
     ↓
特性: 层次结构、递归定义、O(log n)操作
```

6. 二叉搜索树 (BST)

```c
// 🎯 核心特征：有序性、左小右大
struct BSTNode {
    int key;
    struct BSTNode* left;   // 所有值 < key
    struct BSTNode* right;  // 所有值 > key
};

// 结构可视化：
//        [5]
//       /   \
//    [3]     [7]
//    / \     / \
//  [1] [4] [6] [8]

// 🔍 识别特征：
// - 左子树所有值 < 根 < 右子树所有值
// - 中序遍历得到有序序列
// - 搜索路径确定
```

可视化记忆：

```
代码: if (key < root→key) 搜索左子树
     ↓
结构:     [根]
        /    \
    [小值]   [大值]
     ↓
特性: 有序存储、快速搜索、可能不平衡
```

7. AVL树 / 红黑树

```c
// 🎯 核心特征：平衡因子、旋转操作
struct AVLNode {
    int key;
    int height;  // ← 平衡信息！
    struct AVLNode* left;
    struct AVLNode* right;
};

// 旋转操作可视化：
// 不平衡: 
//      [3]
//        \
//        [5]
//          \
//          [7]
// 左旋转后:
//      [5]
//     /   \
//   [3]   [7]

// 🔍 识别特征：
// - 节点存储高度/颜色信息
// - 旋转操作函数
// - 平衡检查逻辑
```

可视化记忆：

```
代码: height 字段 + 旋转函数
     ↓
结构: 保持平衡的二叉搜索树
     ↓  
特性: 自平衡、严格O(log n)、复杂插入
```

---

🕸️ 复杂结构

8. 哈希表 (Hash Table)

```c
// 🎯 核心特征：键值映射、哈希函数
typedef struct {
    int key;
    int value;
    int occupied;  // ← 占用标记！
} HashEntry;

HashEntry table[SIZE];

// 操作可视化：
// 键: "apple" → 哈希函数 → 索引3
// 表: [0][1][2][apple:red][4]...
// 冲突: "banana" → 索引3 → 线性探测 → 索引4

// 🔍 识别特征：
// - 哈希函数计算索引
// - 冲突解决机制（线性探测、链地址）
// - 负载因子控制
```

可视化记忆：

```
代码: hash(key) % size → 索引
     ↓
结构: 数组 + 冲突解决策略
     ↓
特性: O(1)平均访问、处理冲突、空间换时间
```

9. 图 (Graph)

```c
// 🎯 核心特征：顶点+边、邻接关系
// 邻接矩阵表示：
int graph[V][V] = {
    {0, 1, 1, 0},
    {1, 0, 1, 1},
    {1, 1, 0, 0},
    {0, 1, 0, 0}
};

// 邻接表表示：
struct GraphNode {
    int vertex;
    struct GraphNode* next;  // ← 邻接链表！
};

// 可视化：
// 顶点0: [1] → [2] → NULL
// 顶点1: [0] → [2] → [3] → NULL

// 🔍 识别特征：
// - 顶点集合 + 边集合
// - 邻接矩阵或邻接表
// - BFS/DFS遍历
```

可视化记忆：

```
代码: 邻接矩阵 或 邻接链表
     ↓
结构:  顶点网络 + 连接边
     ↓
特性: 复杂关系、路径查找、多种表示法
```

10. 堆 (Heap)

```c
// 🎯 核心特征：完全二叉树、堆序性
typedef struct {
    int* data;     // ← 数组存储
    int size;
    int capacity;
} MaxHeap;

// 结构可视化：
//         [90]
//        /    \
//     [80]     [70]
//     /  \     /
//   [60] [50][20]

// 数组存储: [90, 80, 70, 60, 50, 20]

// 🔍 识别特征：
// - 数组表示完全二叉树
// - 父节点 > 子节点（大顶堆）
// - 上浮/下沉操作
```

可视化记忆：

```
代码: 数组 + 父子索引计算 (i→2i+1, 2i+2)
     ↓
结构: 完全二叉树，根为极值
     ↓
特性: 快速获取最值、优先级队列
```

---

🔄 操作复杂度速查表

数据结构 访问 搜索 插入 删除 识别特征
数组 O(1) O(n) O(n) O(n) arr[i] 直接访问
链表 O(n) O(n) O(1) O(1) node→next 指针链接
栈 O(1) O(n) O(1) O(1) top 指针，LIFO
队列 O(1) O(n) O(1) O(1) front/rear，FIFO
BST O(log n) O(log n) O(log n) O(log n) 左小右大，递归结构
哈希表 O(1) O(1) O(1) O(1) 键值映射，冲突处理
堆 O(1) O(n) O(log n) O(log n) 数组存储，堆序性

---

🎯 代码识别训练

练习1：这是什么数据结构？

```c
struct Node {
    int data;
    struct Node* prev;
    struct Node* next;
};
```

答案：双向链表（特征：prev和next指针）

练习2：这是什么数据结构？

```c
int find(int x) {
    return parent[x] == x ? x : parent[x] = find(parent[x]);
}
```

答案：并查集（特征：路径压缩的find操作）

练习3：这是什么操作？

```c
while (top != -1 && data[top] < current) {
    // 弹出栈顶元素
    top--;
}
```

答案：单调栈操作（特征：维护栈内单调性）

---